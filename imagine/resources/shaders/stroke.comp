#version 450

layout (local_size_x=16, local_size_y=16) in;

struct Path {
    // bool evenodd;
    float opacity;
    uint segments;
    uint linecap;
    float stroke_width;
    vec4 fill_color;
    vec4 stroke_color;
    vec4 bounds;
    mat3 transform;
};

struct Ellipse {
    float opacity;
    float radius;
    float aspect_ratio;
    float stroke_width;
    vec4 fill_color;
    vec4 stroke_color;
    mat3 transform;
};

layout(set=0, binding=0) uniform ConfigBuffer {
    vec2 resolution;
    mat3 view;
};

layout(set=1, binding=0) readonly buffer SegmentBuffer {
    float segments[];
};

layout(set=1, binding=1) readonly buffer PathBuffer {
    Path path[];
};

layout(set=1, binding=2) readonly buffer EllipseBuffer {
    Ellipse ellipse[];
};

layout(set=1, binding=3, rgba8) writeonly uniform image2D stroke;

bool buttcap(vec2 p, float thickness, vec2 a, vec2 b) {
    vec2 p12 = b - a;
    vec2 p13 = p - a;
    float d = dot(p12, p13) / length(p12);
    vec2 p4 = a + normalize(p12) * d;

    return length(p4 - p) < thickness &&
           length(p4 - a) <= length(p12) &&
           length(p4 - b) <= length(p12);
}

bool roundcap(vec2 p, float thickness, vec2 a, vec2 b) {
	vec2 ba = b - a;
	vec2 pa = p - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
	return length(pa - h * ba) < thickness;
}

void main() {
    vec3 view_position = view * vec3(
        2 * gl_GlobalInvocationID.x / resolution.x - 1.0,
        -(2 * gl_GlobalInvocationID.y / resolution.y - 1.0),
        1
    );
    view_position.x *= resolution.x / resolution.y;

    for (int i = 0; i < ellipse.length(); i++) {
        vec3 position = ellipse[i].transform * view_position;
        position.y *= ellipse[i].aspect_ratio;
        if (abs(length(position.xy) - ellipse[i].radius) < ellipse[i].stroke_width) {
            imageStore(
                stroke,
                ivec2(gl_GlobalInvocationID.xy),
                ellipse[i].opacity * ellipse[i].stroke_color
            );
        }
    }

    uint offset = 0;
    for (uint i = 0; i < path.length(); i++) {
        vec3 position = path[i].transform * view_position;
        for (uint j = offset; j < offset + 4 * path[i].segments; j += 4) {
            vec2 p1 = vec2(segments[j], segments[j+1]);
            vec2 p2 = vec2(segments[j+2], segments[j+3]);
            if (path[i].linecap == 0)
                continue;

            if (path[i].linecap == 1 && roundcap(position.xy, path[i].stroke_width, p1, p2) ||
                path[i].linecap == 2 && buttcap(position.xy, path[i].stroke_width, p1, p2)) {
                imageStore(
                    stroke,
                    ivec2(gl_GlobalInvocationID.xy),
                    path[i].opacity * path[i].stroke_color
                );
            }
        }

        offset += path[i].segments;
    }
}