#version 450

layout (local_size_x=16, local_size_y=16) in;

struct Path {
    // bool evenodd;
    float opacity;
    uint segments;
    vec4 fill_color;
    vec4 stroke_color;
    vec4 bounds;
    mat3 transform;
};

layout(set=0, binding=0) uniform ConfigBuffer {
    vec2 resolution;
    mat3 view;
};

layout(set=1, binding=0) readonly buffer SegmentBuffer {
    float segments[];
};

layout(set=1, binding=1) readonly buffer PathBuffer {
    Path path[];
};

layout(set=1, binding=2, rgba8) writeonly uniform image2D stroke;

const float width = 20.0;
const bool evenodd = true;

bool ccw(vec2 a, vec2 b, vec2 c) {
    return (b.x - a.x) * (c.y - a.y) > (b.y - a.y) * (c.x - a.x);
}

void main() {
    vec3 view_position = view * vec3(
        2 * gl_GlobalInvocationID.x / resolution.x - 1.0,
        -(2 * gl_GlobalInvocationID.y / resolution.y - 1.0),
        1
    );
    view_position.x *= resolution.x / resolution.y;

    uint offset = 0;
    for (uint i = 0; i < path.length(); i++) {
        vec3 position = path[i].transform * view_position;

        if (position.x > path[i].bounds.x && position.x < path[i].bounds.z &&
            position.y > path[i].bounds.y && position.y < path[i].bounds.w
        ) {
            uint left = 0;
            uint right = 0;
            for (uint j = offset; j < offset + 4 * path[i].segments; j += 4) {
                vec2 p1 = vec2(segments[j], segments[j+1]);
                vec2 p2 = vec2(segments[j+2], segments[j+3]);
                if (p1.y < position.y == p2.y < position.y)
                    continue;

                if (ccw(p1, p2, position.xy) == p1.y > p2.y) right++;
                else left++;
            }

            if (evenodd && right % 2 == 0 || !evenodd && (left > 0 || right > 0)) {
                imageStore(
                    stroke,
                    ivec2(gl_GlobalInvocationID.xy),
                    path[i].opacity * path[i].stroke_color
                );
            }
        }

        offset += path[i].segments;
    }
}

// void main() {
//     vec3 view_position = view * vec3(
//         2 * gl_GlobalInvocationID.x / resolution.x - 1.0,
//         -(2 * gl_GlobalInvocationID.y / resolution.y - 1.0),
//         1
//     );
//     view_position.x *= resolution.x / resolution.y;

//     uint offset = 0;
//     for (uint i = 0; i < path.length(); i++) {
//         vec3 position = path[i].transform * view_position;

//         if (position.x > path[i].bounds.x && position.x < path[i].bounds.z &&
//             position.y > path[i].bounds.y && position.y < path[i].bounds.w
//         ) {
//             for (uint j = offset; j < offset + 4 * path[i].segments; j += 4) {
//                 vec2 p1 = vec2(segments[j], segments[j+1]);
//                 vec2 p2 = vec2(segments[j+2], segments[j+3]);
//                 if (p1.y < position.y != p2.y < position.y &&
//                     abs(ccw(p1, p2, position.xy)) < width) {
//                     imageStore(
//                         stroke,
//                         ivec2(gl_GlobalInvocationID.xy),
//                         path[i].opacity * path[i].stroke_color
//                     );
//                 }
//             }
//         }

//         offset += path[i].segments;
//     }
// }