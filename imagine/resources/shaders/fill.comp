#version 450

layout (local_size_x=16, local_size_y=16) in;

struct Path {
    // bool evenodd;
    float opacity;
    uint segments;
    vec4 fill_color;
    vec4 stroke_color;
    vec4 bounds;
    mat3 transform;
};

layout(set=0, binding=0) uniform ConfigBuffer {
    // bool clear;
    vec4 clear_color;
    vec2 resolution;
    mat3 view;
};

layout(set=1, binding=0) readonly buffer SegmentBuffer {
    float segments[];
};

layout(set=1, binding=1) readonly buffer PathBuffer {
    Path path[];
};

layout(set=1, binding=2, rgba8) writeonly uniform image2D fill;

const bool evenodd = true;

bool ccw(vec2 a, vec2 b, vec2 c) {
    return (b.x - a.x) * (c.y - a.y) > (b.y - a.y) * (c.x - a.x);
}

void main() {
    bool blank = true;
    vec3 view_position = view * vec3(
        2 * gl_GlobalInvocationID.x / resolution.x - 1.0,
        -(2 * gl_GlobalInvocationID.y / resolution.y - 1.0),
        1
    );
    view_position.x *= resolution.x / resolution.y;

    uint offset = 0;
    for (uint i = 0; i < path.length(); i++) {
        vec3 position = path[i].transform * view_position;

        // Find intersecting segments if within the bounds of the path
        if (position.x > path[i].bounds.x && position.x < path[i].bounds.z &&
            position.y > path[i].bounds.y && position.y < path[i].bounds.w
        ) {
            uint left = 0;
            uint right = 0;
            for (uint j = offset; j < offset + 4 * path[i].segments; j += 4) {
                vec2 p1 = vec2(segments[j], segments[j+1]);
                vec2 p2 = vec2(segments[j+2], segments[j+3]);
                //  Skip the segment if y intersects the segment
                if (p1.y < position.y == p2.y < position.y)
                    continue;

                if (ccw(p1, p2, position.xy) == p1.y > p2.y) right++;
                else left++;
            }

            // Fill shape evenodd or nonzero based on fill rule
            if (evenodd && right % 2 != 0 || !evenodd && left > 0 && right > 0) {
            // if (evenodd && right % 2 != 0 || !evenodd && left != right) {
                blank = false;
                imageStore(
                    fill,
                    ivec2(gl_GlobalInvocationID.xy),
                    path[i].opacity * path[i].fill_color
                );
            }
        }

        offset += path[i].segments;
    }

    if (blank) imageStore(fill, ivec2(gl_GlobalInvocationID.xy), clear_color);
}